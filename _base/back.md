# sorteo_project/urls.py

from django.contrib import admin
from django.urls import path, include
from rest_framework import routers
from sorteo_app.views import (
    UploadCSVView,
    realizar_sorteo,
    ListadoSorteos,
    ListadoResultadosSorteo,
    ListadoRegistroActividad,
    listar_provincias,
    listar_localidades
)
from sorteo_app.views.views_sorteo import PremioViewSet
from sorteo_app.views.download_templates import DownloadParticipantesTemplate, DownloadListaNegraTemplate
from sorteo_app.views.views_lists import ListLoadedData, ClearParticipantes, ClearListaNegra
from sorteo_app.views.blacklist import AddToBlacklist
from sorteo_app.views.add_participant import AddToParticipants
from sorteo_app.views.reports import ReportesView, EstadisticasView
from sorteo_app.views.scheduled_sorteos import ScheduledSorteosList, ScheduledSorteoDetail

router = routers.DefaultRouter()
router.register(r'premios', PremioViewSet, basename='premio')

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/upload_csv/', UploadCSVView.as_view(), name='upload_csv'),
    path('api/lists/', ListLoadedData.as_view(), name='list_loaded_data'),
    path('api/lists/clear/participantes/', ClearParticipantes.as_view(), name='clear_participantes'),
    path('api/lists/clear/blacklist/', ClearListaNegra.as_view(), name='clear_blacklist'),
    path('api/blacklist/add/', AddToBlacklist.as_view(), name='add_to_blacklist'),
    path('api/participants/add/', AddToParticipants.as_view(), name='add_to_participants'),
    path('api/download_template/participantes/', DownloadParticipantesTemplate.as_view(), name='download_template_participantes'),
    path('api/download_template/lista_negra/', DownloadListaNegraTemplate.as_view(), name='download_template_lista_negra'),
    path('api/sortear/', realizar_sorteo, name='realizar_sorteo'),
    path('api/sorteos/', ListadoSorteos.as_view(), name='listado_sorteos'),
    path('api/resultados_sorteo/', ListadoResultadosSorteo.as_view(), name='listado_resultados_sorteo'),
    path('api/registro_actividad/', ListadoRegistroActividad.as_view(), name='listado_registro_actividad'),
    path('api/provincias/', listar_provincias, name='listar_provincias'),
    path('api/localidades/', listar_localidades, name='listar_localidades'),
    # Funcionalidades adicionales:
    path('api/reports/', ReportesView.as_view(), name='reports'),
    path('api/estadisticas/', EstadisticasView.as_view(), name='estadisticas'),
    path('api/scheduled/', ScheduledSorteosList.as_view(), name='scheduled_sorteos_list'),
    path('api/scheduled/<int:pk>/', ScheduledSorteoDetail.as_view(), name='scheduled_sorteo_detail'),
    path('api/', include(router.urls)),
]



# sorteo_project/settings.py

"""
Django settings for sorteo_project project.
Generated by 'django-admin startproject' using Django 5.1.5.
Para más información, visita https://docs.djangoproject.com/en/5.1/topics/settings/
y https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
import dj_database_url
from dotenv import load_dotenv
import os
import logging.config

load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY', "django-insecure-*!)y=(x-y1vj5s5i^y5a_zv(4z1&wvl%f00umni1x6cv@8hwd2")

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv('ENV', 'development') == 'development'

ALLOWED_HOSTS = ['web-production-0252.up.railway.app', 'localhost', '127.0.0.1']

# DATABASE
if DEBUG:
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / "db.sqlite3",
        }
    }
else:
    DATABASES = {
        'default': dj_database_url.config(
            default=os.getenv('DATABASE_URL'),
            conn_max_age=600,
            ssl_require=True
        )
    }

# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "whitenoise.runserver_nostatic",
    # Apps de terceros
    'rest_framework',
    'corsheaders',
    # Tu app
    'sorteo_app',
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    'corsheaders.middleware.CorsMiddleware',
]

# Configurar CORS
CORS_ALLOWED_ORIGINS = [
  "http://localhost:3000",
  "https://teco-sorteos.netlify.app",
]
CORS_ALLOW_ALL_ORIGINS = True

ROOT_URLCONF = "sorteo_project.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "sorteo_project.wsgi.application"

# DRF configuration: se incluye autenticación y permisos básicos (se puede ampliar)
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',  # Cambiar a IsAuthenticated en producción
    ],
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        # 'rest_framework.authentication.TokenAuthentication',  # habilitar si usas tokens
    ],
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",},
]

LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True

STATIC_URL = "static/"
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'sorteo_app/static')]
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
STORAGES = {
    "staticfiles": {
        "BACKEND": "whitenoise.storage.CompressedManifestStaticFilesStorage",
    }
}

CSRF_TRUSTED_ORIGINS = ["http://*", "https://web-production-0252.up.railway.app"]

# Configuración de Logging
LOGGING_CONFIG = None
LOGLEVEL = os.getenv('LOGLEVEL', 'INFO').upper()
logging.config.dictConfig({
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': LOGLEVEL,
    },
})

# Posibles mejoras: agregar configuración de email, roles, etc.





# sorteo_app/serializers.py

from rest_framework import serializers
from .models import Participante, RegistroActividad, Sorteo, SorteoPremio, ResultadoSorteo, Premio, UserProfile

class UserProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserProfile
        fields = ['localidad', 'provincia']

class ParticipanteSerializer(serializers.ModelSerializer):
    class Meta:
        model = Participante
        fields = ['id', 'nombre', 'apellido', 'area', 'dominio', 'cargo', 'email', 'localidad', 'provincia']

class RegistroActividadSerializer(serializers.ModelSerializer):
    class Meta:
        model = RegistroActividad
        fields = '__all__'

class PremioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Premio
        fields = ['id', 'nombre', 'stock']

class SorteoPremioSerializer(serializers.ModelSerializer):
    premio = PremioSerializer(read_only=True)
    # Hacemos el campo writable usando source='premio'
    premio_id = serializers.PrimaryKeyRelatedField(queryset=Premio.objects.all(), source='premio')

    class Meta:
        model = SorteoPremio
        fields = ['premio', 'premio_id', 'orden_item', 'cantidad']

class SorteoSimpleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Sorteo
        fields = ['id', 'nombre']

class SorteoSerializer(serializers.ModelSerializer):
    # Usamos el serializer de SorteoPremio para el campo de premios
    premios = SorteoPremioSerializer(many=True, source='sorteopremios')

    class Meta:
        model = Sorteo
        fields = [
            'id',
            'nombre',
            'descripcion',
            'fecha_hora',
            'fecha_programada',
            'provincia',
            'localidad',
            'premios'
        ]

    def validate_nombre(self, value):
        if not value.strip():
            return "Sorteo sin nombre"
        return value

    def create(self, validated_data):
        # Eliminar el campo extra 'participants_snapshot' si está presente
        # validated_data.pop("participants_snapshot", None)
        premios_data = validated_data.pop('sorteopremios', [])
        sorteo = Sorteo.objects.create(**validated_data)
        for premio_data in premios_data:
            premio = premio_data['premio']
            orden_item = premio_data['orden_item']
            cantidad = premio_data['cantidad']

            if premio.stock < cantidad:
                raise serializers.ValidationError(f'No hay suficiente stock para el premio {premio.nombre}')

            # Disminuir el stock del premio solo si se está realizando el sorteo (no al agendar)
            if not validated_data.get('fecha_programada'):
                premio.stock -= cantidad
                premio.save()

            SorteoPremio.objects.create(
                sorteo=sorteo,
                premio=premio,
                orden_item=orden_item,
                cantidad=cantidad
            )
        return sorteo

class ResultadoSorteoSerializer(serializers.ModelSerializer):
    participante = ParticipanteSerializer(read_only=True)
    premio = PremioSerializer(read_only=True)
    sorteo = serializers.SerializerMethodField()

    class Meta:
        model = ResultadoSorteo
        fields = ['id', 'sorteo', 'participante', 'premio', 'fecha']

    def get_sorteo(self, obj):
        if obj.sorteo:
            return {'id': obj.sorteo.id, 'nombre': obj.sorteo.nombre}
        return None




# sorteo_app/models.py

from django.db import models
from django.contrib.auth.models import User
from django.db.models.signals import post_save
from django.dispatch import receiver

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    localidad = models.CharField(max_length=255)
    provincia = models.CharField(max_length=255)

    def __str__(self):
        return f'Perfil de {self.user.username}'

class Participante(models.Model):
    id = models.IntegerField(primary_key=True)
    nombre = models.CharField(max_length=255)
    apellido = models.CharField(max_length=255)
    area = models.CharField(max_length=255, blank=True, null=True)
    dominio = models.CharField(max_length=255, blank=True, null=True)
    cargo = models.CharField(max_length=255, blank=True, null=True)
    email = models.EmailField()
    localidad = models.CharField(max_length=255)
    provincia = models.CharField(max_length=255)

    def __str__(self):
        return f"{self.nombre} {self.apellido}"

@receiver(post_save, sender=User)
def crear_guardar_perfil(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)
    instance.profile.save()

class Premio(models.Model):
    nombre = models.CharField(max_length=255, unique=True)
    stock = models.PositiveIntegerField(default=0)

    def __str__(self):
        return self.nombre

class Sorteo(models.Model):
    nombre = models.CharField(max_length=255)
    descripcion = models.TextField(blank=True)
    premios = models.ManyToManyField(Premio, through='SorteoPremio')
    fecha_hora = models.DateTimeField(auto_now_add=True)
    # Campo para sorteo agendado (opcional)
    fecha_programada = models.DateTimeField(null=True, blank=True)
    # Campos opcionales para almacenar los filtros aplicados al agendar el sorteo
    provincia = models.CharField(max_length=255, blank=True, default='')
    localidad = models.CharField(max_length=255, blank=True, default='')

    def __str__(self):
        return self.nombre

class SorteoPremio(models.Model):
    sorteo = models.ForeignKey(Sorteo, on_delete=models.CASCADE, related_name='sorteopremios')
    premio = models.ForeignKey(Premio, on_delete=models.CASCADE)
    orden_item = models.PositiveIntegerField()
    cantidad = models.PositiveIntegerField()

    class Meta:
        unique_together = ('sorteo', 'premio')
        ordering = ['orden_item']

    def __str__(self):
        return f'{self.premio.nombre} en {self.sorteo.nombre} - Orden: {self.orden_item}, Cantidad: {self.cantidad}'

class ResultadoSorteo(models.Model):
    sorteo = models.ForeignKey(Sorteo, on_delete=models.CASCADE)
    participante = models.ForeignKey(Participante, on_delete=models.CASCADE)
    premio = models.ForeignKey(Premio, on_delete=models.CASCADE)
    fecha = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.participante} ganó {self.premio} en {self.sorteo}"

class RegistroActividad(models.Model):
    evento = models.CharField(max_length=255)
    fecha_hora = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.evento} at {self.fecha_hora}"

class ListaNegra(models.Model):
    id = models.IntegerField(primary_key=True)
    nombre = models.CharField(max_length=255, blank=True, default="-")
    apellido = models.CharField(max_length=255, blank=True, default="-")
    area = models.CharField(max_length=255, blank=True, default="-")
    dominio = models.CharField(max_length=255, blank=True, default="-")
    cargo = models.CharField(max_length=255, blank=True, default="-")
    email = models.CharField(max_length=255, blank=True, default="-")
    localidad = models.CharField(max_length=255, blank=True, default="-")
    provincia = models.CharField(max_length=255, blank=True, default="-")

    def __str__(self):
        return f"{self.id} - {self.nombre} {self.apellido}"




# sorteo_app/apps.py

from django.apps import AppConfig

class SorteoAppConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "sorteo_app"




# sorteo_app/admin.py

from django.contrib import admin
from sorteo_app.models import Premio

@admin.register(Premio)
class PremioAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'stock')
    search_fields = ('nombre',)




# sorteo_app/views/__init__.py

# Importar vistas de filtros
from .views_filters import listar_provincias, listar_localidades

# Importar vistas de sorteo
from .views_sorteo import (
    realizar_sorteo,
    ListadoSorteos,
    ListadoResultadosSorteo,
    ListadoRegistroActividad
)

# Importar vistas de subida de CSV
from .views_upload import UploadCSVView

__all__ = [
    'listar_provincias',
    'listar_localidades',
    'realizar_sorteo',
    'ListadoSorteos',
    'ListadoResultadosSorteo',
    'ListadoRegistroActividad',
    'UploadCSVView'
]




# sorteo_app/views/add_participant.py

import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from ..models import Participante, ListaNegra

logger = logging.getLogger(__name__)

class AddToParticipants(APIView):
    """
    Permite agregar manualmente un registro a la lista de participantes.
    Se esperan recibir los siguientes campos en JSON:
      - id (legajo) *
      - nombre *
      - apellido *
      - email *
      - area (opcional)
      - dominio (opcional)
      - cargo (opcional)
      - localidad (opcional)
      - provincia (opcional)

    (*) Campos requeridos.
    Además, si el legajo ya se encuentra en la lista negra, se elimina para no duplicar.
    """
    def post(self, request, format=None):
        data = request.data
        required_fields = ['id', 'nombre', 'apellido', 'email']
        missing = [field for field in required_fields if field not in data or not str(data[field]).strip()]
        if missing:
            logger.warning("Faltan campos requeridos: %s", missing)
            return Response(
                {"error": f"Faltan campos requeridos: {', '.join(missing)}"},
                status=status.HTTP_400_BAD_REQUEST
            )
        try:
            legajo = int(data['id'])
        except ValueError:
            logger.warning("El legajo debe ser numérico: %s", data.get('id'))
            return Response(
                {"error": "El legajo (id) debe ser un número."},
                status=status.HTTP_400_BAD_REQUEST
            )

        try:
            participante, created = Participante.objects.update_or_create(
                id=legajo,
                defaults={
                    'nombre': data['nombre'],
                    'apellido': data['apellido'],
                    'email': data['email'],
                    'area': data.get('area', ''),
                    'dominio': data.get('dominio', ''),
                    'cargo': data.get('cargo', ''),
                    'localidad': data.get('localidad', ''),
                    'provincia': data.get('provincia', ''),
                }
            )
            # Si el participante está en la lista negra, se elimina
            if ListaNegra.objects.filter(id=legajo).exists():
                ListaNegra.objects.filter(id=legajo).delete()
        except Exception as e:
            logger.error("Error al crear/actualizar participante: %s", e)
            return Response({"error": "Error interno al procesar el participante."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        message = "Participante creado exitosamente." if created else "Participante actualizado exitosamente."
        return Response({"message": message}, status=status.HTTP_200_OK)




# sorteo_app/views/blacklist.py

import logging
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from ..models import ListaNegra, Participante

logger = logging.getLogger(__name__)

class AddToBlacklist(APIView):
    """
    Permite agregar individualmente un participante a la lista negra.
    Se espera recibir un JSON con el campo "id". Si el participante existe en la base de participantes,
    se toman sus datos para la lista negra; de lo contrario, se usan valores por defecto.
    Además, se elimina el registro de Participante para evitar duplicidad.
    """
    def post(self, request, format=None):
        participant_id = request.data.get('id')
        if not participant_id:
            logger.warning("Falta el legajo del participante en blacklist")
            return Response({"error": "Falta el legajo del participante."}, status=status.HTTP_400_BAD_REQUEST)
        try:
            participant_id = int(participant_id)
        except ValueError:
            logger.warning("El id debe ser numérico en blacklist: %s", participant_id)
            return Response({"error": "El id debe ser un número."}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            participante = Participante.objects.get(id=participant_id)
            defaults_data = {
                'nombre': participante.nombre,
                'apellido': participante.apellido,
                'area': participante.area if participante.area else '-',
                'dominio': participante.dominio if participante.dominio else '-',
                'cargo': participante.cargo if participante.cargo else '-',
                'email': participante.email,
                'localidad': participante.localidad,
                'provincia': participante.provincia,
            }
        except Participante.DoesNotExist:
            defaults_data = {
                'nombre': '-',
                'apellido': '-',
                'area': '-',
                'dominio': '-',
                'cargo': '-',
                'email': '-',
                'localidad': '-',
                'provincia': '-',
            }
        
        try:
            obj, created = ListaNegra.objects.update_or_create(
                id=participant_id,
                defaults=defaults_data
            )
            if Participante.objects.filter(id=participant_id).exists():
                Participante.objects.filter(id=participant_id).delete()
        except Exception as e:
            logger.error("Error en blacklist: %s", e)
            return Response({"error": "Error interno al agregar a la lista negra."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
        message = "Participante agregado a la lista de no incluidos." if created else "El participante ya se encontraba en la lista."
        return Response({"message": message}, status=status.HTTP_200_OK)




# sorteo_app/views/download_templates.py

import csv
from django.http import HttpResponse
from rest_framework.views import APIView
from rest_framework.permissions import AllowAny

class DownloadParticipantesTemplate(APIView):
    """
    Devuelve un archivo CSV con la plantilla para participantes.
    Orden de columnas: ['id', 'nombre', 'apellido', 'area', 'dominio', 'cargo', 'email', 'localidad', 'provincia']
    """
    permission_classes = [AllowAny]

    def get(self, request, format=None):
        filename = "participantes_template.csv"
        headers = ['id', 'nombre', 'apellido', 'area', 'dominio', 'cargo', 'email', 'localidad', 'provincia']
        example_rows = [
            ['1', 'Juan', 'Pérez', 'Ventas', 'Negocio', 'Ejecutivo', 'juan.perez@example.com', 'La Plata', 'Buenos Aires'],
            ['2', 'María', 'González', 'Marketing', 'Digital', 'Analista', 'maria.gonzalez@example.com', 'Mar del Plata', 'Buenos Aires']
        ]
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        writer = csv.writer(response)
        writer.writerow(headers)
        for row in example_rows:
            writer.writerow(row)
        return response

class DownloadListaNegraTemplate(APIView):
    """
    Devuelve un archivo CSV con la plantilla para la lista negra.
    Se utiliza el mismo orden de columnas que para participantes, lo que permite incluir además del ID el nombre y los demás datos.
    """
    permission_classes = [AllowAny]

    def get(self, request, format=None):
        filename = "lista_negra_template.csv"
        headers = ['id', 'nombre', 'apellido', 'area', 'dominio', 'cargo', 'email', 'localidad', 'provincia']
        example_rows = [
            ['10', 'Pedro', 'Suárez', 'Finanzas', 'Negocio', 'Analista', 'pedro.suarez@example.com', 'Buenos Aires', 'Buenos Aires'],
            ['11', 'Luciana', 'Rodríguez', 'Marketing', 'Digital', 'Coordinadora', 'luciana.rodriguez@example.com', 'Mar del Plata', 'Buenos Aires']
        ]
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        writer = csv.writer(response)
        writer.writerow(headers)
        for row in example_rows:
            writer.writerow(row)
        return response




# sorteo_app/views/participants.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from ..models import Participante, ListaNegra

class AddToParticipants(APIView):
    """
    Permite agregar manualmente un participante a la base de Participante.
    Se esperan en el JSON los campos: id, nombre, apellido y email (obligatorios),
    y opcionalmente: área, dominio, cargo, localidad, provincia.
    Si el participante existe en la lista de no incluidos, se lo remueve de allí.
    """
    def post(self, request, format=None):
        data = request.data
        # Verificar campos requeridos
        for campo in ['id', 'nombre', 'apellido', 'email']:
            if not data.get(campo):
                return Response({"error": f"El campo {campo} es obligatorio."}, status=status.HTTP_400_BAD_REQUEST)
        try:
            legajo = int(data.get('id'))
        except ValueError:
            return Response({"error": "El legajo debe ser un número."}, status=status.HTTP_400_BAD_REQUEST)
        
        # Remover de ListaNegra si existe
        ListaNegra.objects.filter(id=legajo).delete()
        
        participante, created = Participante.objects.update_or_create(
            id=legajo,
            defaults={
                'nombre': data.get('nombre'),
                'apellido': data.get('apellido'),
                'email': data.get('email'),
                'area': data.get('area', ''),
                'dominio': data.get('dominio', ''),
                'cargo': data.get('cargo', ''),
                'localidad': data.get('localidad', ''),
                'provincia': data.get('provincia', ''),
            }
        )
        if created:
            message = "Participante agregado exitosamente."
        else:
            message = "Participante actualizado exitosamente."
        return Response({"message": message}, status=status.HTTP_200_OK)




# sorteo_app/views/reports.py

import logging
from django.db.models import Count
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from ..models import RegistroActividad, Participante, ListaNegra

logger = logging.getLogger(__name__)

class ReportesView(APIView):
    """
    Endpoint para obtener el historial de actividades (RegistroActividad)
    y otros logs relevantes.
    """
    def get(self, request, format=None):
        try:
            logs = list(RegistroActividad.objects.all().order_by('-fecha_hora').values())
        except Exception as e:
            logger.error("Error obteniendo logs: %s", e)
            return Response({"error": "Error interno al obtener los logs."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        return Response({"logs": logs}, status=status.HTTP_200_OK)

class EstadisticasView(APIView):
    """
    Devuelve estadísticas básicas, por ejemplo:
      - Número total de participantes.
      - Número total en la lista negra.
      - Número total de sorteos realizados (según RegistroActividad, si lo deseas).
    """
    def get(self, request, format=None):
        try:
            total_participantes = Participante.objects.count()
            total_blacklist = ListaNegra.objects.count()
            total_actividades = RegistroActividad.objects.count()
        except Exception as e:
            logger.error("Error obteniendo estadísticas: %s", e)
            return Response({"error": "Error interno al obtener las estadísticas."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        data = {
            "total_participantes": total_participantes,
            "total_blacklist": total_blacklist,
            "total_actividades": total_actividades,
        }
        return Response(data, status=status.HTTP_200_OK)

class ScheduleSorteoView(APIView):
    """
    Stub para programación de sorteos.
    Aquí se podría implementar la lógica para agendar sorteos en fechas y horas específicas,
    por ejemplo, integrando Celery y Django-Celery-Beat para tareas programadas.
    """
    def post(self, request, format=None):
        # Ejemplo: recibir payload con 'fecha' y 'sorteo_id' (o datos para crear el sorteo)
        # y programar la ejecución del sorteo.
        # Se recomienda usar Celery para tareas asíncronas y programadas.
        data = request.data
        # Validar datos y programar la tarea.
        # Por ahora devolvemos un stub.
        return Response({"message": "Sorteo programado (stub)."}, status=status.HTTP_200_OK)




# sorteo_app/views/scheduled_sorteos.py

from rest_framework import generics
from ..models import Sorteo
from ..serializers import SorteoSerializer

class ScheduledSorteosList(generics.ListCreateAPIView):
    """
    Lista todos los sorteos agendados y permite crear uno nuevo.
    Se asume que los sorteos agendados se diferencian de los sorteos ejecutados
    porque tienen el campo 'fecha_programada' definido y 'fecha_hora' nulo.
    """
    queryset = Sorteo.objects.filter(fecha_programada__isnull=False)
    serializer_class = SorteoSerializer

class ScheduledSorteoDetail(generics.RetrieveUpdateDestroyAPIView):
    """
    Permite obtener, actualizar o eliminar un sorteo programado.
    """
    queryset = Sorteo.objects.filter(fecha_programada__isnull=False)
    serializer_class = SorteoSerializer



    # sorteo_app/views/views_filters.py

from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from ..models import Participante  # Asegurate de importar Participante, no User

@api_view(['GET'])
def listar_provincias(request):
    # Obtener provincias únicas de Participante
    provincias = Participante.objects.values_list('provincia', flat=True).distinct()
    provincias_list = sorted(provincias)
    return Response(provincias_list, status=status.HTTP_200_OK)

@api_view(['GET'])
def listar_localidades(request):
    provincia = request.GET.get('provincia')
    if provincia:
        localidades = Participante.objects.filter(provincia__iexact=provincia).values_list('localidad', flat=True).distinct()
    else:
        localidades = Participante.objects.values_list('localidad', flat=True).distinct()
    localidades_list = sorted(localidades)
    return Response(localidades_list, status=status.HTTP_200_OK)




# sorteo_app/views/views_lists.py

from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from ..models import Participante, ListaNegra

class ListLoadedData(APIView):
    """
    Devuelve el contenido actual:
      - Participantes: todos los registros de Participante.
      - Blacklist: todos los registros de ListaNegra.
    """
    def get(self, request):
        try:
            participantes = list(Participante.objects.all().values())
            blacklist = list(ListaNegra.objects.all().values())
        except Exception as e:
            return Response({"error": "Error al obtener los datos."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        return Response({'participantes': participantes, 'blacklist': blacklist}, status=status.HTTP_200_OK)

class ClearParticipantes(APIView):
    """
    Elimina todos los registros de Participante.
    """
    def delete(self, request):
        try:
            deleted, _ = Participante.objects.all().delete()
        except Exception as e:
            return Response({"error": "Error al eliminar participantes."}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        return Response({"message": "Participantes eliminados", "deleted": deleted}, status=status.HTTP_200_OK)

class ClearListaNegra(APIView):
    """
    Elimina todos los registros de la Lista Negra y reintegra a los participantes.
    Es decir, los participantes excluidos se vuelven a agregar a la base de participantes.
    """
    def delete(self, request):
        try:
            with transaction.atomic():
                # Obtener todos los registros de la lista negra
                blacklist_items = ListaNegra.objects.all()
                reinserted = 0
                for item in blacklist_items:
                    # Solo reinsertar si no existe ya en Participante
                    if not Participante.objects.filter(id=item.id).exists():
                        Participante.objects.create(
                            id=item.id,
                            nombre=item.nombre if item.nombre != '-' else '',
                            apellido=item.apellido if item.apellido != '-' else '',
                            email=item.email if item.email != '-' else '',
                            area=item.area if item.area != '-' else '',
                            dominio=item.dominio if item.dominio != '-' else '',
                            cargo=item.cargo if item.cargo != '-' else '',
                            localidad=item.localidad if item.localidad != '-' else '',
                            provincia=item.provincia if item.provincia != '-' else '',
                        )
                        reinserted += 1
                # Luego, borrar la lista negra
                deleted, _ = ListaNegra.objects.all().delete()
        except Exception as e:
            return Response({
                'error': f'Error al vaciar y reintegrar la lista de no incluidos: {str(e)}'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response({
            'message': f'Lista de no incluidos vaciada. Se reintegraron {reinserted} participantes.',
            'deleted': deleted
        }, status=status.HTTP_200_OK)



        # sorteo_app/views/views_sorteo.py

import random
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status, viewsets
from rest_framework.generics import ListAPIView
from ..models import RegistroActividad, Sorteo, SorteoPremio, ResultadoSorteo, Premio, Participante
from ..serializers import (
    SorteoSerializer,
    ResultadoSorteoSerializer,
    RegistroActividadSerializer,
    PremioSerializer
)

# ViewSet para gestionar Premios (para el CRUD de premios en el backend)
class PremioViewSet(viewsets.ModelViewSet):
    queryset = Premio.objects.all()
    serializer_class = PremioSerializer

@api_view(['POST'])
def realizar_sorteo(request):
    """
    Realiza o agenda un sorteo.

    Si el payload incluye el campo "fecha_programada" (no nulo), se entiende que el sorteo
    se agenda y solo se registra la actividad sin asignar ganadores ni descontar stock.

    En cambio, si no se incluye (o es nulo) "fecha_programada", se procede a:
      - Crear el sorteo usando el serializer.
      - Filtrar los participantes (por provincia y/o localidad, si se reciben esos filtros).
      - Validar que haya suficientes participantes para asignar todos los premios.
      - Asignar de forma aleatoria los premios a los participantes.
      - Disminuir el stock de cada premio (solo en el sorteo "realizado").
      - Registrar la actividad.
      - Devolver en la respuesta un resumen con el ID del sorteo, nombre y la lista de premios con sus ganadores.
    """
    # Extraer filtros (opcional)
    provincia = request.data.get('provincia')
    localidad = request.data.get('localidad')

    # Crear el sorteo mediante el serializer (este serializer se encarga de descartar campos extra como "participants_snapshot")
    serializer = SorteoSerializer(data=request.data)
    if not serializer.is_valid():
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    try:
        sorteo = serializer.save()
    except Exception as e:
        return Response(
            {'error': f"Error al crear el sorteo: {str(e)}"},
            status=status.HTTP_400_BAD_REQUEST
        )

    # Si no se agenda (no hay fecha_programada), se ejecuta el sorteo
    if not sorteo.fecha_programada:
        # Filtrar participantes (por defecto se toman todos; si se incluye provincia/localidad, se filtra)
        participantes_query = Participante.objects.all()
        if provincia:
            participantes_query = participantes_query.filter(provincia__iexact=provincia)
        if localidad:
            participantes_query = participantes_query.filter(localidad__iexact=localidad)
        participantes_disponibles = list(participantes_query)

        if not participantes_disponibles:
            error_msg = "No se encontraron participantes"
            if provincia and localidad:
                error_msg += f" para la provincia '{provincia}' y localidad '{localidad}'."
            elif provincia:
                error_msg += f" para la provincia '{provincia}'."
            elif localidad:
                error_msg += f" para la localidad '{localidad}'."
            else:
                error_msg += "."
            return Response({'error': error_msg}, status=status.HTTP_400_BAD_REQUEST)

        # Validar que existan suficientes participantes para asignar los premios
        try:
            premios_data = request.data.get('premios', [])
            total_premios = sum(item['cantidad'] for item in premios_data)
        except Exception as e:
            return Response(
                {'error': f"Error en el campo 'premios': {str(e)}"},
                status=status.HTTP_400_BAD_REQUEST
            )

        if total_premios > len(participantes_disponibles):
            return Response(
                {'error': f"No hay suficientes participantes para asignar {total_premios} premios. Participantes disponibles: {len(participantes_disponibles)}."},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Mezclar aleatoriamente la lista de participantes
        random.shuffle(participantes_disponibles)
        ganadores_info = []
        premios_sorted = SorteoPremio.objects.filter(sorteo=sorteo).order_by('orden_item')

        for sorteo_premio in premios_sorted:
            cantidad = sorteo_premio.cantidad
            premio = sorteo_premio.premio
            if cantidad > len(participantes_disponibles):
                return Response(
                    {'error': f"No hay suficientes participantes para asignar el premio '{premio.nombre}' (se requieren {cantidad}, disponibles {len(participantes_disponibles)})."},
                    status=status.HTTP_400_BAD_REQUEST
                )
            ganadores = participantes_disponibles[:cantidad]
            participantes_disponibles = participantes_disponibles[cantidad:]
            ganadores_data = []
            for ganador in ganadores:
                try:
                    ResultadoSorteo.objects.create(
                        sorteo=sorteo,
                        participante=ganador,
                        premio=premio
                    )
                except Exception as e:
                    return Response(
                        {'error': f"Error al asignar el premio '{premio.nombre}' al participante ID {ganador.id}: {str(e)}"},
                        status=status.HTTP_500_INTERNAL_SERVER_ERROR
                    )
                ganadores_data.append({
                    'id_ganador': ganador.id,
                    'nombre': ganador.nombre,
                    'apellido': ganador.apellido,
                    'email': ganador.email,
                })
            ganadores_info.append({
                'nombre_item': premio.nombre,
                'orden_item': sorteo_premio.orden_item,
                'cantidad': cantidad,
                'ganadores': ganadores_data
            })

        try:
            RegistroActividad.objects.create(
                evento=f"Sorteo (ID={sorteo.id}) '{sorteo.nombre}' realizado con {premios_sorted.count()} premios y {total_premios} ganadores."
            )
        except Exception as e:
            print(f"Error al registrar actividad: {str(e)}")

        data_response = {
            'sorteo_id': sorteo.id,
            'nombre_sorteo': sorteo.nombre,
            'items': ganadores_info
        }
        return Response(data_response, status=status.HTTP_200_OK)
    else:
        # Si se agenda el sorteo (fecha_programada está presente), solo se registra la actividad sin asignar ganadores ni modificar stock.
        try:
            RegistroActividad.objects.create(
                evento=f"Sorteo agendado (ID={sorteo.id}) '{sorteo.nombre}' creado."
            )
        except Exception as e:
            print(f"Error al registrar actividad: {str(e)}")
        return Response(
            {'message': f"Sorteo agendado (ID={sorteo.id}) creado."},
            status=status.HTTP_200_OK
        )

class ListadoSorteos(ListAPIView):
    queryset = Sorteo.objects.all().order_by('-fecha_hora')
    serializer_class = SorteoSerializer

class ListadoResultadosSorteo(ListAPIView):
    queryset = ResultadoSorteo.objects.all()
    serializer_class = ResultadoSorteoSerializer

class ListadoRegistroActividad(ListAPIView):
    queryset = RegistroActividad.objects.all().order_by('-fecha_hora')
    serializer_class = RegistroActividadSerializer




# sorteo_app/views/views_upload.py

import csv
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from django.db import transaction
from io import TextIOWrapper
from ..models import RegistroActividad, Participante, ListaNegra

class UploadCSVView(APIView):
    """
    Permite subir de a un archivo:
      - usuarios.csv: Crea/actualiza Participante.
      - lista_negra.csv: Crea/actualiza ListaNegra con los datos completos del CSV.
    """
    def post(self, request, format=None):
        file_usuarios = request.FILES.get('usuarios')
        file_lista_negra = request.FILES.get('lista_negra')

        mensaje = {}
        total_excluidos = 0

        # Procesar CSV de lista negra (si se envía)
        if file_lista_negra:
            try:
                text_file_ln = TextIOWrapper(file_lista_negra.file, encoding='utf-8')
                reader_ln = csv.DictReader(text_file_ln)
                count_ln = 0
                errores_ln = []
                for row in reader_ln:
                    try:
                        user_id = int(row['ID'])
                        ListaNegra.objects.update_or_create(
                            id=user_id,
                            defaults={
                                'nombre': row.get('Nombre', '-').strip() or '-',
                                'apellido': row.get('Apellido', '-').strip() or '-',
                                'area': row.get('Area', '-').strip() or '-',
                                'dominio': row.get('Dominio', '-').strip() or '-',
                                'cargo': row.get('Cargo', '-').strip() or '-',
                                'email': row.get('Email', '-').strip() or '-',
                                'localidad': row.get('Localidad', '-').strip() or '-',
                                'provincia': row.get('Provincia', '-').strip() or '-',
                            }
                        )
                        count_ln += 1
                    except ValueError:
                        errores_ln.append(f"ID inválido en lista_negra: {row.get('ID')}")
                mensaje['lista_negra'] = f"Se procesaron {count_ln} registros en la lista."
                if errores_ln:
                    mensaje['errores_lista_negra'] = errores_ln
            except Exception as e:
                return Response({'error': f"Error al procesar lista_negra.csv: {str(e)}"},
                                status=status.HTTP_400_BAD_REQUEST)

        # Procesar CSV de usuarios (si se envía)
        if file_usuarios:
            contador = 0
            errores = []
            try:
                text_file_u = TextIOWrapper(file_usuarios.file, encoding='utf-8')
                reader_u = csv.DictReader(text_file_u)
                with transaction.atomic():
                    for row in reader_u:
                        try:
                            user_id = int(row['ID'])
                            # Si el usuario ya se encuentra en la lista negra, se omite
                            if ListaNegra.objects.filter(id=user_id).exists():
                                total_excluidos += 1
                                continue
                            Participante.objects.update_or_create(
                                id=user_id,
                                defaults={
                                    'nombre': row['Nombre'],
                                    'apellido': row['Apellido'],
                                    'area': row.get('Area', ''),
                                    'dominio': row.get('Dominio', ''),
                                    'cargo': row.get('Cargo', ''),
                                    'email': row['Email'],
                                    'localidad': row['Localidad'],
                                    'provincia': row['Provincia'],
                                }
                            )
                            contador += 1
                        except KeyError as e:
                            errores.append({'row': row, 'error': f'Campo faltante: {e}'})
                        except ValueError:
                            errores.append({'row': row, 'error': f'ID inválido: {row.get("ID")}'})
                        except Exception as e:
                            errores.append({'row': row, 'error': str(e)})
                RegistroActividad.objects.create(
                    evento=f"Carga de participantes desde archivo CSV; se cargaron/actualizaron {contador} participantes. No incluidos {total_excluidos}."
                )
                mensaje['usuarios'] = f"Se cargaron {contador} participantes. No incluidos {total_excluidos} registros."
                if errores:
                    mensaje['errores_usuarios'] = errores
            except Exception as e:
                return Response({'error': f"Error al procesar usuarios.csv: {str(e)}"},
                                status=status.HTTP_400_BAD_REQUEST)

        if not file_usuarios and not file_lista_negra:
            return Response({'error': 'Debe enviar al menos uno de los archivos.'},
                            status=status.HTTP_400_BAD_REQUEST)

        return Response(mensaje, status=status.HTTP_200_OK)




# sorteo_app/management/commands/load_premios.py

from django.core.management.base import BaseCommand
from sorteo_app.models import Premio
import random

class Command(BaseCommand):
    help = 'Carga 10 premios de prueba con stock aleatorio'

    def handle(self, *args, **kwargs):
        sample_premios = [
            'TV 42 pulgadas',
            'Smartphone Samsung Galaxy',
            'Laptop HP 15"',
            'Tablet iPad Pro',
            'Cámara Canon EOS',
            'Audífonos Bose',
            'Smartwatch Apple',
            'Televisor LG 55 pulgadas',
            'Consola PlayStation 5',
            'Bicicleta de montaña'
        ]

        for nombre in sample_premios:
            stock = random.randint(1, 10)
            premio, created = Premio.objects.get_or_create(nombre=nombre, defaults={'stock': stock})
            if created:
                self.stdout.write(self.style.SUCCESS(f'Creado premio: {nombre} con stock {stock}'))
            else:
                self.stdout.write(f'El premio {nombre} ya existe con stock {premio.stock}')




# sorteo_app/management/commands/cargar_csv.py

from django.core.management.base import BaseCommand, CommandError
import csv
from sorteo_app.models import Participante, RegistroActividad

class Command(BaseCommand):
    help = 'Carga datos de participantes desde CSV y excluye legajos en la lista.'

    def add_arguments(self, parser):
        parser.add_argument(
            '--usuarios',
            type=str,
            help='Ruta al archivo CSV de usuarios'
        )
        parser.add_argument(
            '--lista_negra',
            type=str,
            help='Ruta al archivo CSV de lista'
        )

    def handle(self, *args, **options):
        ruta_usuarios = options['usuarios'] or 'participantes.csv'
        ruta_lista_negra = options['lista_negra'] or 'no_incluidos.csv'

        # Leer IDs de la lista negra
        blacklist_ids = set()
        try:
            with open(ruta_lista_negra, 'r', encoding='utf-8') as f_black:
                reader = csv.DictReader(f_black)
                for row in reader:
                    blacklist_ids.add(int(row['ID']))
        except FileNotFoundError:
            raise CommandError(f"No se encontró el archivo: {ruta_lista_negra}")

        # Leer y crear/actualizar participantes (excluyendo los que estén en la lista negra)
        try:
            with open(ruta_usuarios, 'r', encoding='utf-8') as f_users:
                reader = csv.DictReader(f_users)
                contador = 0
                for row in reader:
                    user_id = int(row['ID'])
                    if user_id in blacklist_ids:
                        continue

                    Participante.objects.update_or_create(
                        id=user_id,
                        defaults={
                            'nombre': row['Nombre'],
                            'apellido': row['Apellido'],
                            'email': row['Email'],
                            'localidad': row['Localidad'],
                            'provincia': row['Provincia']
                        }
                    )
                    contador += 1

                self.stdout.write(self.style.SUCCESS(
                    f'Se cargaron/actualizaron {contador} participantes.'
                ))

                RegistroActividad.objects.create(
                    evento=f"Carga de participantes desde {ruta_usuarios}; no incluidos {len(blacklist_ids)} legajos."
                )
        except FileNotFoundError:
            raise CommandError(f"No se encontró el archivo de participantes: {ruta_usuarios}")




